From 66822d7627a3eac69658027481252aa9f28b7462 Mon Sep 17 00:00:00 2001
From: Andrey Mihadyuk <mihadyuk@ntlab.com>
Date: Tue, 3 May 2016 15:35:10 +0300
Subject: [PATCH] saturn: Added rs485 support.

---
 drivers/tty/serial/imx.c | 34 ++++++++++++++++++++++++++++++++++
 1 file changed, 34 insertions(+)

diff --git a/drivers/tty/serial/imx.c b/drivers/tty/serial/imx.c
index 016e4be..28ce3ad 100644
--- a/drivers/tty/serial/imx.c
+++ b/drivers/tty/serial/imx.c
@@ -43,6 +43,7 @@
 #include <asm/irq.h>
 #include <linux/platform_data/serial-imx.h>
 #include <linux/platform_data/dma-imx.h>
+#include <linux/gpio/consumer.h>
 
 /* Register definitions */
 #define URXD0 0x0  /* Receiver Register */
@@ -219,6 +220,7 @@ struct imx_port {
 	wait_queue_head_t	dma_wait;
 	unsigned int            saved_reg[10];
 	bool			context_saved;
+	struct gpio_desc 	*gpio_rs485_txen;
 };
 
 struct imx_port_ucrs {
@@ -385,6 +387,15 @@ static void imx_stop_tx(struct uart_port *port)
 		temp &= ~UCR4_TCEN;
 		writel(temp, port->membase + UCR4);
 	}
+	if (sport->gpio_rs485_txen) {
+		/* wait for finish tx operations.*/
+		while (!(readl(port->membase + USR2) & USR2_TXDC)) {
+			udelay(5);
+			barrier();
+		}
+                /*printk(KERN_WARNING "rs485: 0");*/
+		gpiod_set_value(sport->gpio_rs485_txen, 0);
+	}
 }
 
 /*
@@ -578,6 +589,10 @@ static void imx_start_tx(struct uart_port *port)
 	struct imx_port *sport = (struct imx_port *)port;
 	unsigned long temp;
 
+	if (sport->gpio_rs485_txen) {
+                /*printk(KERN_WARNING "rs485: 1");*/
+		gpiod_set_value(sport->gpio_rs485_txen, 1);
+	}
 	if (port->rs485.flags & SER_RS485_ENABLED) {
 		/* enable transmitter and shifter empty irq */
 		temp = readl(port->membase + UCR2);
@@ -1860,6 +1875,7 @@ static int serial_imx_probe_dt(struct imx_port *sport,
 	const struct of_device_id *of_id =
 			of_match_device(imx_uart_dt_ids, &pdev->dev);
 	int ret;
+	struct gpio_desc *rs485_txen;
 
 	if (!np)
 		/* no device tree device */
@@ -1878,6 +1894,16 @@ static int serial_imx_probe_dt(struct imx_port *sport,
 	if (of_get_property(np, "fsl,dte-mode", NULL))
 		sport->dte_mode = 1;
 
+	rs485_txen = gpiod_get(&pdev->dev, "rs485_txen", GPIOD_OUT_LOW);
+	if (IS_ERR(rs485_txen)) {
+                /*printk(KERN_WARNING "rs485: unable to open gpio err: %d, dev: %d", (int)rs485_txen, (int)sport->port.dev);*/
+		sport->gpio_rs485_txen = 0;
+	}
+	else {
+                /*printk(KERN_WARNING "rs485: gpio %d initialized.", desc_to_gpio(rs485_txen));*/
+		sport->gpio_rs485_txen = rs485_txen;
+	}
+
 	sport->devdata = of_id->data;
 
 	return 0;
@@ -2009,6 +2035,14 @@ static int serial_imx_remove(struct platform_device *pdev)
 {
 	struct imx_port *sport = platform_get_drvdata(pdev);
 
+	if (sport->gpio_rs485_txen) {
+		/*
+		 * it seems there is no function to free gpio pin.
+		 * */
+		/*gpiod_free(sport->gpio_rs485_txen);*/
+                /*printk(KERN_WARNING "rs485: gpio released.");*/
+		sport->gpio_rs485_txen = 0;
+	}
 	return uart_remove_one_port(&imx_reg, &sport->port);
 }
 
-- 
2.8.2

