From e64409b779bbb7b59fe9fb7e3b90de1f3aa9de93 Mon Sep 17 00:00:00 2001
From: Andrey Mihadyuk <mihadyuk@ntlab.com>
Date: Mon, 26 Sep 2016 11:07:33 +0300
Subject: [PATCH] imx uart: Software rs485 support.

---
 drivers/tty/serial/imx.c | 36 ++++++++++++++++++++++++++++++++++++
 1 file changed, 36 insertions(+)

diff --git a/drivers/tty/serial/imx.c b/drivers/tty/serial/imx.c
index 0df2b1c..3562916 100644
--- a/drivers/tty/serial/imx.c
+++ b/drivers/tty/serial/imx.c
@@ -43,6 +43,7 @@
 #include <asm/irq.h>
 #include <linux/platform_data/serial-imx.h>
 #include <linux/platform_data/dma-imx.h>
+#include <linux/gpio/consumer.h>
 
 #include "serial_mctrl_gpio.h"
 
@@ -227,6 +228,8 @@ struct imx_port {
 	wait_queue_head_t	dma_wait;
 	unsigned int            saved_reg[10];
 	bool			context_saved;
+
+	struct gpio_desc 	*gpio_rs485_txen;
 };
 
 struct imx_port_ucrs {
@@ -369,6 +372,15 @@ static void imx_stop_tx(struct uart_port *port)
 		temp &= ~UCR4_TCEN;
 		writel(temp, port->membase + UCR4);
 	}
+	if (sport->gpio_rs485_txen) {
+		/* wait for finish tx operations.*/
+		while (!(readl(port->membase + USR2) & USR2_TXDC)) {
+			udelay(5);
+			barrier();
+		}
+                /*printk(KERN_WARNING "rs485: 0");*/
+		gpiod_set_value(sport->gpio_rs485_txen, 0);
+	}
 }
 
 /*
@@ -564,6 +576,10 @@ static void imx_start_tx(struct uart_port *port)
 	struct imx_port *sport = (struct imx_port *)port;
 	unsigned long temp;
 
+	if (sport->gpio_rs485_txen) {
+                /*printk(KERN_WARNING "rs485: 1");*/
+		gpiod_set_value(sport->gpio_rs485_txen, 1);
+	}
 	if (port->rs485.flags & SER_RS485_ENABLED) {
 		temp = readl(port->membase + UCR2);
 		if (port->rs485.flags & SER_RS485_RTS_ON_SEND)
@@ -1967,6 +1983,7 @@ static int serial_imx_probe_dt(struct imx_port *sport,
 {
 	struct device_node *np = pdev->dev.of_node;
 	int ret;
+	struct gpio_desc *rs485_txen;
 
 	sport->devdata = of_device_get_match_data(&pdev->dev);
 	if (!sport->devdata)
@@ -1987,6 +2004,17 @@ static int serial_imx_probe_dt(struct imx_port *sport,
 	if (of_get_property(np, "fsl,dte-mode", NULL))
 		sport->dte_mode = 1;
 
+	rs485_txen = gpiod_get(&pdev->dev, "rs485_txen", GPIOD_OUT_LOW);
+	if (IS_ERR(rs485_txen)) {
+                /*printk(KERN_WARNING "rs485: unable to open gpio err: %d, dev: %d", (int)rs485_txen, (int)sport->port.dev);*/
+		sport->gpio_rs485_txen = 0;
+	}
+	else {
+                /*printk(KERN_WARNING "rs485: gpio %d initialized.", desc_to_gpio(rs485_txen));*/
+		sport->gpio_rs485_txen = rs485_txen;
+	}
+
+
 	return 0;
 }
 #else
@@ -2120,6 +2148,14 @@ static int serial_imx_remove(struct platform_device *pdev)
 {
 	struct imx_port *sport = platform_get_drvdata(pdev);
 
+	if (sport->gpio_rs485_txen) {
+		/*
+		 * it seems there is no function to free gpio pin.
+		 * */
+		/*gpiod_free(sport->gpio_rs485_txen);*/
+                /*printk(KERN_WARNING "rs485: gpio released.");*/
+		sport->gpio_rs485_txen = 0;
+	}
 	return uart_remove_one_port(&imx_reg, &sport->port);
 }
 
-- 
2.10.0

